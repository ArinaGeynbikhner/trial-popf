<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Model Scroll Explosion</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let scene, camera, renderer, model, originalPositions = [], scrollProgress = 0;

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 1.7;
      camera.position.y = 0.4;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(1, 1, 1);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      const loader = new THREE.GLTFLoader();
      loader.load('model.glb', (gltf) => {
        model = gltf.scene;
        model.rotation.y = 5.1;
        scene.add(model);

        // Сохраняем оригинальные позиции и нормали
        model.traverse((child) => {
          if (child.isMesh) {
            const geometry = child.geometry;
            geometry.computeVertexNormals();
            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;
            originalPositions.push({
              id: geometry.id,
              positions: [...positions],
              normals: [...normals],
              geometry: geometry
            });
          }
        });

        animate();
      });

      // Прокрутка
      window.addEventListener('wheel', (event) => {
        if (!model) return;

        scrollProgress += event.deltaY * 0.001;
        scrollProgress = Math.max(0, Math.min(1, scrollProgress));

        updateModel();

        if (scrollProgress === 1) {
          // Переход на другую страницу
          setTimeout(() => {
            window.location.href = 'nextpage.html'; // Замените на нужную ссылку
          }, 500);
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function updateModel() {
      if (!model) return;

      // Масштаб модели от 1 до 2 (можно настроить)
      const scale = 1 + scrollProgress * 1.5;
      model.scale.set(scale, scale, scale);

      // Разлет вершин
      model.traverse((child) => {
        if (child.isMesh) {
          const entry = originalPositions.find(e => e.id === child.geometry.id);
          const positions = child.geometry.attributes.position.array;
          const normals = entry.normals;
          const original = entry.positions;

          for (let i = 0; i < positions.length; i += 3) {
            const nx = normals[i];
            const ny = normals[i + 1];
            const nz = normals[i + 2];
            const amplitude = scrollProgress * 5; // Степень разлёта

            positions[i] = original[i] + nx * amplitude;
            positions[i + 1] = original[i + 1] + ny * amplitude;
            positions[i + 2] = original[i + 2] + nz * amplitude;
          }

          child.geometry.attributes.position.needsUpdate = true;
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>

