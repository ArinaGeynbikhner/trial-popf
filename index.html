<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Model with Scroll Explosion and Camera Approach</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let scene, camera, renderer, model, originalPositions, scrollProgress = 0, time = 0, cameraLocked = false;

    // Инициализация сцены
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 1.7;
      camera.position.y = 0.4;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Освещение
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(1, 1, 1);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // Загрузка модели
      const loader = new THREE.GLTFLoader();
      loader.load(
        'model.glb',
        (gltf) => {
          model = gltf.scene;
          // Поворот модели по оси Y
          model.rotation.y = 5.1;
          scene.add(model);

          // Сохранение исходных позиций вершин и расчет нормалей для эффекта взрыва
          originalPositions = [];
          model.traverse((child) => {
            if (child.isMesh) {
              const geometry = child.geometry;
              geometry.computeVertexNormals(); // Вычисляем нормали для эффекта взрыва
              const positions = geometry.attributes.position.array;
              const normals = geometry.attributes.normal.array;
              originalPositions.push({ positions: [...positions], normals: [...normals] });
              geometry.attributes.position.needsUpdate = true;
            }
          });

          animate();
        },
        undefined,
        (error) => {
          console.error('Ошибка загрузки модели:', error);
          alert('Не удалось загрузить модель model.glb. Проверьте путь к файлу или его наличие.');
        }
      );

      // Обработка события прокрутки
      window.addEventListener('wheel', (event) => {
        if (!model || cameraLocked) return; // Пропускаем, если модель не загружена или камера зафиксирована
        scrollProgress += event.deltaY * 0.001; // Чувствительность прокрутки
        scrollProgress = Math.max(0, Math.min(1, scrollProgress)); // Ограничение 0–1
        if (scrollProgress === 1) cameraLocked = true; // Фиксируем камеру при достижении максимума
        updateModel();
      });
    }

    // Обновление позиций вершин и камеры
    function updateModel() {
      if (!model) return; // Пропускаем, если модель не загружена

      // Перемещение модели ближе к камере
      model.position.z = scrollProgress * -1; // Движение от z=0 к z=-1

      // Перемещение камеры ближе к модели
      if (!cameraLocked) {
        camera.position.z = 1.7 - scrollProgress * 1.2; // От z=1.7 к z=0.5
      }

      model.traverse((child) => {
        if (child.isMesh) {
          const positions = child.geometry.attributes.position.array;
          const normals = child.geometry.attributes.normal.array;
          const original = originalPositions[child.geometry.id] || originalPositions[0];
          for (let i = 0; i < positions.length; i += 3) {
            // Используем нормали для направления "взрыва"
            const nx = original.normals[i];
            const ny = original.normals[i + 1];
            const nz = original.normals[i + 2];
            // Пульсирующий эффект с использованием sin и времени
            const pulse = Math.sin(time * 5) * 0.5 + 0.5; // Частота и амплитуда пульсации
            const amplitude = scrollProgress * pulse * 5; // Амплитуда зависит от scrollProgress
            positions[i] = original.positions[i] + nx * amplitude;
            positions[i + 1] = original.positions[i + 1] + ny * amplitude;
            positions[i + 2] = original.positions[i + 2] + nz * amplitude;
          }
          child.geometry.attributes.position.needsUpdate = true;
        }
      });
    }

    // Анимация
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016; // Примерно 60 кадров в секунду (1/60)
      updateModel(); // Обновляем модель в каждом кадре для пульсации
      renderer.render(scene, camera);
    }

    // Обработка изменения размера окна
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>